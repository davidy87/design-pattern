## Proxy Pattern?

프록시 패턴은 대상 객체에 접근하기 전, 그 접근에 대한 흐름을 가로채 대생 객체 앞단의 인터페이스 역할을 하는 패턴이다.

- 이를 통해 객체의 속성, 변환 등을 보완하며, 보안, 데이터 검증, caching, logging 등에 사용된다.

- 프록시 패턴은 프록시 객체에서도 사용되지만, 프록시 서버에도 활용된다.

**프록시 서버에서의 캐싱**
> 캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 다시 저 멀리 있는 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는 것을 말한다. 이를 통해 불필요하게 외부와 연결하지 않기 때문에 트래픽을 줄일 수 있다는 장점이 있다.

<br>

## 구조

프록시 패턴의 전체적인 구조는 다음과 같다.

![proxy.png](proxy.png)

1. **Service Interface**: Service의 인터페이스를 선언한다. Proxy가 Service 객체로 위장하기 위해서는 
이 인터페이스를 구현해야 한다.

2. **Service**: 핵심 기능이 담긴 클래스이다. Subject라고 부르기도 한다.

3. **Proxy**: 프록시 기능을 담당하는 클래스이다. Service 객체를 가리키는 필드를 갖고 있으며, 요청의 처리를 
완료하면 처리된 요청을 Service에게 전달한다.

4. Client: Service 기능에 접근하고자 하는 클라이언트이다. Service에 직접 접근하는 것이 아닌, Proxy에게 요청을 
전달한다.

<br>

## 종류

프록시 패턴은 활용하는 방법에 따라 종류가 나눠진다.

### 가상 프록시 (Virtual Proxy)

- 지연 초기화 방식을 사용한다.
- 가끔 사용되지만 항상 메모리에 적재되어 있는 무거운 서비스 객체가 있는 경우에 사용된다.
    - 그래서 실제 객체의 생성에 많은 자원이 소모되지만 사용 빈도는 낮을 때 사용된다.
- 서비스가 시작될 때 객체를 생성하는 대신에, 객체 초기화가 실제로 필요한 시점에 초기화될 수 있도록 지연한다.

### 보호 프록시 (Protection Proxy)

- 프록시가 대상 객체에 대한 접근을 제어한다.
- 특정 클라이언트만 서비스 객체를 사용할 수 있도록 해야 하는 경우 사용된다.
- 프록시 객체를 통해 클라이언트의 자격이 증명된 경우에만 서비스 객체에 요청을 보내는 방식이다.

### 로깅 프록시 (Logging Proxy)

- 대상 객체에 로깅을 해야하는 경우 사용된다.
- 프록시는 서비스의 기능을 실행하기 전에 로깅을 하는 기능을 추가하여 재정의한다.

### 원격 프록시 (Remote Proxy)

- 프록시 클래스는 로컬에, 대상 객체는 원격 서버에 존재하는 경우에 사용된다.
- 프록시 객체는 네트워크를 통해 클라이언트의 요청을 전달하여 네트워크와 관련된 불필요한 작업들을 처리하고 결과만 전달한다.
- 클라이언트의 입장에서는 프록시를 사용하는 것이므로 서비스가 원격에 있든 로컬에 있든 신경 쓸 필요가 없게 된다.

### 캐싱 프록시 (Caching Proxy)

- 데이터의 크기가 큰 경우 캐싱을 통해 이미 기록되어 있는 데이터를 재사용한다.
- 클라이언트의 요청의 결과를 캐시하고, 이 캐시의 수명을 관리한다.

<br>

## 장단점

### 장점

- OCP 준수 - 대상 객체를 변경하지 않고도 새로운 기능을 추가할 수 있다.
- SRP 준수 - 대상 객체는 본래 기능에만 집중하고, 이외의 기능은 프록시에게 위임하여 다중 책임을 피할 수 있다.
- 핵심 비즈니스 로직 외의 부가 기능들을 유연하게 적용할 수 있다.

### 단점

- 부가기능이 많을 수록 여러 프록시 클래스를 도입해야 하므로 코드의 복잡도가 증가한다.
- 프록시 자체의 기능이 무거워지면 성능에 영향이 갈 수 있다.

<br>

## 출처
https://refactoring.guru/ko/design-patterns/builder