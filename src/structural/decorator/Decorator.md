## Decorator Pattern?

데코레이터 패턴은 객체들을 새로운 행동을 포함한 특수 래퍼 객체들 내에 넣어서 이 행동들을 해당 객체들에 연결시키는 
디자인 패턴이다.

대상 객체에 대한 기능 확장이나 변경이 필요한 경우, 객체의 결합을 통해 서브 클래스 대신 쓸 수 있는 유연한 패턴이다.

<br>

## 구조

데코레이터 패턴의 전체적인 구조는 다음과 같다.

![decorator.png](decorator.png)

1. **Component:** 원본 객체와 Decorator 객체를 모두 묶는 인터페이스이다.
2. **ConcreteComponent:** 원본 객체를 구현한 것이다.
3. **Base Decorator**: 추상화된 Decorator 클래스이다.
    - 원본 객체를 합성을 사용하여 포함하고 있으며, Component 인터페이스의 구현 메서드를 갖는다.
4. **ConcreteDecorator**: 구체적인 Decorator 클래스이다.
    - Base Decorator를 상속받아 구현하고 추가적인 기능을 제공한다.

<br>

## 장단점

### 장점

- 새로운 자식 클래스를 만들지 않고도 객체의 행동을 확장할 수 있다.
- 런타임에 객체의 기능을 변경할 수 있다.
- SRP 준수 - 각  Decorator 클래스마다 단일 기능을 갖는다.
- OCP 준수 - 클라이언트 코드 수정 없이 Decorator 클래스를 추가해 기능을 확장 가능하다.

### 단점

- 데코레이터를 중첩으로 사용하고자 하는 경우에 적용하는 순서가 매우 중요하며, 이 순서를 의존하지 않는 방식으로는 구현하기가 어렵다.
- 데코레이테를 조합할 때, 생성 코드가 지저분해질 수 있다.
    - E.g. `new Decorator1(new Decorator2(new Decorator3())))`

<br>

## Proxy vs. Decorator

자세히 살펴보면 프록시 패턴과 데코레이터 패턴이 매우 유사한 구조를 갖고 있는 것을 확인할 수 있다. GOF 디자인 패턴에서는
이 둘을 구분하는 기준을 설명한다.

### **GOF 디자인 패턴**

둘 다 프록시를 사용하는 방법이지만, GOF 디자인 패턴에서는 이 둘을 의도(intent)에 따라서 프록시 패턴과 데코레이터 
패턴으로 구분한다.

- **프록시 패턴**: 접근 제어가 목적
- **데코레이터 패턴**: 새로운 기능 추가가 목적

둘 다 프록시를 사용하지만, 의도가 다르다는 점이 핵심이다. 용어가 프록시 패턴이라고 해서 이 패턴만 프록시를 사용하는 
것은 아니다. 데코레이터 패턴도 프록시를 사용하는 것이다.

<br>

## 출처
https://refactoring.guru/ko/design-patterns/builder