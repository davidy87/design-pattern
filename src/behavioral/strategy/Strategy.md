## Strategy Pattern?

전략 패턴은 정책 패턴(policy pattern)이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 “직접” 수정하지 않고, 
전략이라고 부르는 “캡슐화한 알고리즘”을 context 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴이다.

우리가 어떤 제품을 살 때 네이버페이, 카카오페이 등 다양한 방법으로 결제하듯이, 결제 방식의 “전략” 만 바꿔서 두 가지 
방식으로 결제할 수 있게 구현하는 것을 하나의 예로 들 수 있다.

<br>

## 구조

전략 패턴의 전체적인 구조는 다음과 같다.

![strategy.png](strategy.png)

1. **Context**: 구상 전략에 대한 참조를 갖고 있으며, Strategy 인터페이스를 통해서만 해당 전략 객체와 소통한다.

2. **Strategy**: 모든 전략 구현체에 대한 공통적인 기능을 제공하는 인터페이스이다.

3. **ConcreteStrategy**: Strategy 인터페이스를 구현한 전략 구현체이다. Context가 필요한 기능에 따라 다양하게 
변형되어 구현된다.

4. Context는 알고리즘을 실행할 때마다 전략 객체가 Strategy 인터페이스로부터 구현한 실행 메서드를 호출한다. 
Context는 어떤 방식과 어떤 유형의 전략이 실행되는지 알 필요가 없다.

5. **Client**: 클라이언트는 상황에 필요한 전략 객체를 생성해 Context에 전달한다.

<br>

## 장단점

### 장점

- 런타임에 Context 안에서 사용되는 전략 기능을 교체할 수 있다.
- 객체지향 프로그래밍의 특징과 이점을 갖고 있다.
    - DIP, OCP 준수
    - 합성, 다형성, 캡슐화

### 단점

- 필요한 전략이 많아질수록 관리해야할 객체의 수가 늘어난다.
- 만약 필요한 전략이 많지 않고 자주 변경되지 않는다면, 전략 패턴은 프로그램을 더 복잡하게만 만들 뿐이다.
- 적절한 전략을 적용하려면 전략들에 대한 특성과 전략 간의 차이점을 잘 파악하고 있어야 한다.

<br>

## 출처
https://refactoring.guru/ko/design-patterns/builder